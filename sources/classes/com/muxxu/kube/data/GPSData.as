package com.muxxu.kube.data {	import com.muxxu.kube.components.map.IZoomableMapItem;	import com.muxxu.kube.components.map.MapEntry;	import com.muxxu.kube.components.map.icons.MapIconGpsEnd;	import com.muxxu.kube.components.map.icons.MapIconGpsMessage;	import com.muxxu.kube.components.map.icons.MapIconGpsPath;	import com.muxxu.kube.components.map.icons.MapIconGpsStart;	import com.muxxu.kube.components.map.icons.MapIconUserPos;	import com.muxxu.kube.components.syswindowcontent.SystemWindowGPS;	import com.muxxu.kube.controler.FrontControler;	import com.muxxu.kube.crypto.RequestEncrypter;	import com.muxxu.kube.events.GPSDataEvent;	import com.muxxu.kube.events.GPSMapDataEvent;	import com.muxxu.kube.events.LocalConnectionManagerEvent;	import com.muxxu.kube.utils.HTTPPath;	import com.muxxu.kube.views.syswindow.SystemWindow;	import com.muxxu.kube.views.syswindow.SystemWindowManager;	import com.muxxu.kube.vo.Point3D;	import com.muxxu.kube.vo.Templates;	import com.nurun.structure.environnement.label.Label;	import flash.desktop.NativeApplication;	import flash.display.BitmapData;	import flash.errors.IllegalOperationError;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.InvokeEvent;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.net.FileFilter;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.net.URLRequestHeader;	import flash.net.URLRequestMethod;	import flash.utils.ByteArray;		[Event(name="reloadHelp", type="com.muxxu.kube.events.GPSDataEvent")]	[Event(name="dataChanges", type="com.muxxu.kube.events.GPSDataEvent")]	[Event(name="lcConnectError", type="com.muxxu.kube.events.GPSDataEvent")]	[Event(name="lcSecurityError", type="com.muxxu.kube.events.GPSDataEvent")]	[Event(name="lcDataLengthError", type="com.muxxu.kube.events.GPSDataEvent")]	/**	 * Singleton GPSData	 * 	 * @author Francois	 */	public class GPSData extends EventDispatcher {				private static var _instance:GPSData;		private var _data:Vector.<MapEntry>;
		private var _lastArea:Rectangle;
		private var _capturing:Boolean;
		private var _loadFile:File;
		private var _canSynch:Boolean;
		private var _eraseMode:Boolean;
		private var _coordsDone:Array;
		private var _addInfosMode:Boolean;
		private var _lastCoords:Point3D;
		private var _lastZoneIndex:int;
		private var _following:Boolean;
		private var _systemWindowContent:SystemWindowGPS;
		private var _systemWindow:SystemWindow;
						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>GPSData</code>.<br>		 */		public function GPSData(enforcer:SingletonEnforcer) {			if(enforcer == null) throw new IllegalOperationError("A singleton cannot be instanciated!");			initialize();		}
						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Singleton instance getter		 */		public static function getInstance():GPSData {			if(_instance == null)_instance = new  GPSData(new SingletonEnforcer());			return _instance;			}				/**		 * Gets if the profiler is enabled in the mm.cfg file.		 */		public function get mmcfgEnabled():Boolean {			var fs:FileStream = new FileStream();			var file:File = File.userDirectory.resolvePath("mm.cfg");			fs.open(file, FileMode.UPDATE);			var str:String = fs.readUTFBytes(fs.bytesAvailable);			fs.close();			var profiler:String = File.applicationDirectory.resolvePath("kubeProfiler.swf").nativePath;			profiler = profiler.replace(/\\/gi, "/");			profiler = profiler.replace(/\./gi, "\\.");			return str.match(/\s*PreloadSWF=.*kubeProfiler\.swf\s?/gi).length > 0;		}				/**		 * Gets if we can synchronize the game.		 */		public function get canSynchGame():Boolean { return _canSynch; }				/**		 * Gets the erase mode state.		 */		public function get eraseMode():Boolean { return _eraseMode; }				/**		 * Gets the add infos mode state.		 */		public function get addInfosMode():Boolean { return _addInfosMode; }				/**		 * Gets the last user's coordinates.		 */		public function get lastCoords():Point3D { return _lastCoords; }				/**		 * Gets if we are following a path.		 */		public function get following():Boolean { return _following; }						/* ****** *		 * PUBLIC *		 * ****** */				/**		 * Get the zones of a specific area		 */		public function getZones(area:Rectangle, centerOn:MapEntry = null):void {			_lastArea = area;			var data:Vector.<MapEntry> = new Vector.<MapEntry>();			var i:int, len:int, inc:int;			len = _data.length;			for(i = 0; i < len; ++i) {				if(_data[i].x >= area.x && _data[i].x <= area.right				&& _data[i].y >= area.y && _data[i].y <= area.bottom) {					data.push(_data[i]);inc++;				}			}			var center:Point3D = (centerOn != null)? new Point3D(centerOn.x, centerOn.y) : null;			if(_following) {				data.push(new MapEntry(_lastCoords.x, _lastCoords.y, new MapIconUserPos(), null));				center = _lastCoords; 			}			dispatchEvent(new GPSMapDataEvent(GPSMapDataEvent.LOAD_AREA_COMPLETE, 0, area, data, center));		}		/**		 * Loads a file path.		 */		public function loadPath():void {			var filter:Array = [new FileFilter("Kube path (.kpp)", "*.kpp")];			_loadFile.browseForOpen(Label.getLabel("gpsFormLoadPath"), filter);		}				/**		 * Starts capturing movement		 */		public function startCapture():void {			LocalConnectionManager.getInstance().getCurrentZone();			_data = new Vector.<MapEntry>();			_following = false;			_capturing = true;			_canSynch = false;			_coordsDone = [];			_lastZoneIndex = -1;			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));		}		/**		 * Stops capturing movement		 */		public function stopCapture():void {			_capturing = false;			_lastZoneIndex = -1;			if(_data.length > 0) {				var i:int, len:int;				len = _data.length;				for(i = len-1; i > -1; --i) {					if(_data[i].rawData == null || _data[i].rawData.child("message") == undefined) {						var last:MapEntry = _data[i];						_data[i] = new MapEntry(last.x, last.y, createZone(false, true), new XML("<root isEnd='true' />"));						break;					}				}				save();				getZones(new Rectangle(_data[i].x, _data[i].y, _lastArea.width, _lastArea.height), last);			}			_canSynch = _data.length > 0;			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));		}				/**		 * Updates the mm.cfg.		 */		public function updateMmCfg(enable:Boolean):void {			var fs:FileStream = new FileStream();			var file:File = File.userDirectory.resolvePath("mm.cfg");			fs.open(file, FileMode.UPDATE);			var str:String = fs.readUTFBytes(fs.bytesAvailable);			str = str.replace(/\s*PreloadSWF=.*\s?/gi, "");						if(enable) {				str += "\rPreloadSwf="+File.applicationDirectory.resolvePath("trusted/kubeProfiler.swf").nativePath;			}			fs.close();			fs.open(file, FileMode.WRITE);			fs.position = 0;			fs.truncate();			fs.writeUTFBytes(str);			fs.close();		}				/**		 * Ask for help reload.		 */		public function reloadHelp():void {			dispatchEvent(new GPSDataEvent(GPSDataEvent.RELOAD_HELP));		}				/**		 * Changes the erase mode.		 */		public function setEraseMode(value:Boolean):void {			_eraseMode = value;			dispatchEvent(new GPSDataEvent(GPSDataEvent.ERASE_STATE_CHANGE));		}				/**		 * Changes the add infos mode.		 */		public function setAddInfoMode(value:Boolean):void {			_addInfosMode = value;			dispatchEvent(new GPSDataEvent(GPSDataEvent.ADD_INFOS_STATE_CHANGE));		}				/**		 * Saves the current path to an external file.		 */		public function save():void {			var ba:ByteArray = new ByteArray();			ba.writeObject(getDataObject());			var file:File = new File();			file.save(ba, "path.kpp");		}				/**		 * Shows the KPPs list		 */		public function showKPPs():void {			dispatchEvent(new GPSDataEvent(GPSDataEvent.UPLOAD_KPP_COMPLETE));		}				/**		 * Saves the current path to an external file.		 */		public function uploadKPP():void {			var ba:ByteArray = new ByteArray();			ba.writeObject(getDataObject());						var getVars:String = RequestEncrypter.encrypt(null, "&rnd="+Math.random()+"&uid="+SharedObjectManager.getInstance().userIdCrp).data as String;			var header:URLRequestHeader = new URLRequestHeader ("Content-type", "application/octet-stream");			var uploadRequest:URLRequest = new URLRequest(HTTPPath.getPath("uploadKpp")+"?data="+getVars);			uploadRequest.requestHeaders.push(header);			uploadRequest.method = URLRequestMethod.POST;			uploadRequest.data = ba;			var loader:URLLoader = new URLLoader();			loader.addEventListener(Event.COMPLETE, uploadKppCompleteHandler);			loader.addEventListener(IOErrorEvent.IO_ERROR, uploadKppErrorHandler);			loader.load(uploadRequest);		}
		/**		 * Saves the current path to an external file.		 */		public function downloadKPP(id:String):void {			var loader:URLLoader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.BINARY;			loader.addEventListener(Event.COMPLETE, downloadKppCompleteHandler);			loader.addEventListener(IOErrorEvent.IO_ERROR, downloadKppErrorHandler);			loader.load(new URLRequest(HTTPPath.getPath("downloadKpp")+"?id="+id));		}
		/**		 * Registers an informaiton on the map.		 */		public function registerInfo(pos:Point, text:String):void {			var i:int, len:int, entry:MapEntry, existing:MapEntry;			len = _data.length;			for(i = 0; i < len; ++i) {				entry = _data[i];				if(entry.x == pos.x && entry.y == pos.y) {					existing = entry;					break;				}			}			if(existing != null) {				existing.icon = new MapIconGpsMessage();				if(existing.rawData != null) {					existing.rawData.child("message")[0] = text;				}else{					existing.rawData = new XML("<root><message>" + text + "</message></root>");				}			}else{				_data.push(new MapEntry(pos.x, pos.y, new MapIconGpsMessage(), new XML("<root><message>"+text+"</message></root>")));			}			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));			getZones(_lastArea);		}				/**		 * Removes an entry from the list.		 */		public function removeEntry(x:Number, y:Number):void {			var i:int, len:int, entry:MapEntry;			len = _data.length;			for(i = 0; i < len; ++i) {				entry = _data[i];				if(entry.x == x && entry.y == y) {					_data.splice(i, 1)[0];					len --;					i --;				}			}			if(_coordsDone != null) {				delete _coordsDone[x+"_"+y];			}			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));		}				/**		 * Clears the map.		 */		public function clear():void {			_data = new Vector.<MapEntry>();			_following = false;			_capturing = true;			_canSynch = false;			_coordsDone = [];			_lastZoneIndex = -1;			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));			getZones(new Rectangle(0, 0, _lastArea.width, _lastArea.height), new MapEntry(0, 0, null, null));		}				/**		 * Starts the GPS.		 */		public function startGPS():void {			_following = true;			_capturing = false;			LocalConnectionManager.getInstance().getCurrentZone();		}
		/**		 * Stops the GPS.		 */		public function stopGPS():void {			_lastCoords = null;			_following = false;			_lastZoneIndex = -1;			if(_lastCoords != null) {				getZones(new Rectangle(_lastCoords.x, _lastCoords.y, _lastArea.width, _lastArea.height));			}		}				/**		 * Sets the map's bitmapData		 */		public function setMapBmd(bmd:BitmapData):void {			_systemWindowContent.bitmapData = bmd;		}
								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes the class		 */		private function initialize():void {			_loadFile = new File();			_systemWindowContent = new SystemWindowGPS();			_systemWindow = SystemWindowManager.getInstance().create();						_lastZoneIndex = -1;						_loadFile.addEventListener(Event.SELECT, selectForLoadHandler);			_loadFile.addEventListener(Event.COMPLETE, loadPathCompleteHandler);						_data = new Vector.<MapEntry>();			NativeApplication.nativeApplication.addEventListener(InvokeEvent.INVOKE, invokeAppHandler);			LocalConnectionManager.getInstance().addEventListener(LocalConnectionManagerEvent.ENTER_ZONE, enterZoneHandler);		}				/**		 * Called when application is invoked.<br>		 * <br>		 * The application could be invoked, for exemple, by opening a KPP file		 * that have been associated to the SkyTimer.		 */		private function invokeAppHandler(e:InvokeEvent):void {			var i:int, len:int, file:String;			len = e.arguments.length;			for(i = 0; i < len; ++i) {				file = e.arguments[i] as String;				if(file.substr(file.lastIndexOf(".") + 1).toLowerCase() == "kpp") {					loadPathCompleteHandler(null, File.applicationDirectory.resolvePath(e.arguments[i]));					FrontControler.getInstance().viewId = Templates.GPS;					break;				}			}		}				/**		 * Converts the MapEntry collection into a simple array that can be saved		 * in a binary file and transmitted through the LocalConnection.		 */		private function getDataObject():Array {			var objectData:Array = [];			var i:int, len:int, data:MapEntry, obj:Object;			len = _data.length;			for(i = 0; i < len; ++i) {				data = _data[i];				obj = {x:data.x, y:data.y};				if(data.rawData != null) {					obj.d = data.rawData.toXMLString();				}				objectData.push(obj);			}			return objectData;
		}
		/**		 * Called when a file is selected to be loaded.		 */		private function selectForLoadHandler(event:Event):void {			_loadFile.load();		}				/**		 * Called when a path is loaded.		 */		private function loadPathCompleteHandler(event:Event, file:File = null):void {			var data:Array;			if(file != null){				var fs:FileStream = new FileStream();				fs.open(file, FileMode.READ);				data = fs.readObject();				fs.close();			}else{				data = _loadFile.data.readObject();			}			parsePathData(data);		}				/**		 * Parses a KPP data.		 */		private function parsePathData(data:Array):void {			var i:int, len:int, entry:Object, isStart:Boolean, isEnd:Boolean, isInfo:Boolean, hasStart:Boolean, hasEnd:Boolean, xml:XML, start:MapEntry;			len = data.length;			_data = new Vector.<MapEntry>();			for(i = 0; i < len; ++i) {				entry = data[i];				xml = null;				isStart = isEnd = isInfo = false;				if(entry.d != undefined) {					xml = new XML(entry.d);					isStart = xml.@isStart == "true";					isEnd = xml.@isEnd == "true";					isInfo = xml.child("message") != undefined;					hasStart ||= isStart;					hasEnd ||= isEnd;				}				_data.push(new MapEntry(entry.x, entry.y, createZone(isStart, isEnd, isInfo), xml));				if(start == null && isStart) {					start = _data[_data.length-1];				}			}			if(!hasStart) {				entry = data[0];				_data[0] = new MapEntry(entry.x, entry.y, createZone(true, false), new XML("<root isStart='true' />"));				start = _data[_data.length-1];			}			if(!hasEnd) {				entry = data[data.length-1];				_data[_data.length-1] = new MapEntry(entry.x, entry.y, createZone(false, true), new XML("<root isEnd='true' />"));			}			_canSynch = true;			dispatchEvent(new GPSDataEvent(GPSDataEvent.DATA_CHANGES));			if(_lastArea == null) {				_lastArea = new Rectangle(0,0,600,600);			}			getZones(new Rectangle(start.x, start.y, _lastArea.width, _lastArea.height), start);
		}
		/**		 * Creates a zone shape.		 */		private function createZone(start:Boolean = false, end:Boolean = false, infos:Boolean = false):IZoomableMapItem {			if(start) return new MapIconGpsStart();			if(end) return new MapIconGpsEnd();			if(infos) return new MapIconGpsMessage();			return new MapIconGpsPath();		}				/**		 * Sets the current coordinates the user is at.		 * Called by LocalConnection.		 */		private function enterZoneHandler(event:LocalConnectionManagerEvent):void {			_lastCoords = event.zone;			if(_capturing) {				if(_coordsDone[_lastCoords.x+"_"+_lastCoords.y] == undefined) {					_coordsDone[_lastCoords.x+"_"+_lastCoords.y] = true;					var infos:XML = (_data.length==0)? new XML("<root isStart='true' />") : null;					var center:MapEntry = new MapEntry(_lastCoords.x, _lastCoords.y, createZone(_data.length == 0), infos);					_data.push(center);					getZones(new Rectangle(_lastCoords.x, _lastCoords.y, _lastArea.width, _lastArea.height), center);				}			} else if(_following){				var i:int, len:int, distance:int, distMin:int, index:int, entry:Object, nearest:MapEntry, raw:XML, currZoneIndex:int;								if(_lastZoneIndex == -1) {					len = _data.length;					for(i = len - 1; i > -1; --i) {						raw = _data[i].rawData;						if(raw == null || raw.child("message") == undefined) {							_lastZoneIndex = i;							break;						}					}				}								//If we're following a specific path, check wich cell is the nearest				if(_data != null && _data.length > 0) {					len = _data.length;					distMin = int.MAX_VALUE;					//Check for the next zone to go to.					for(i = len-1; i > -1; --i) {						entry = _data[i];						if(entry.x == _lastCoords.x && entry.y == _lastCoords.y) {							if(i != _lastZoneIndex) {								currZoneIndex = i;								index = i + 1;								break;							}else{								_following = false;								_systemWindowContent.populate(Label.getLabel("gpsArrivedTemplate"), null);								_systemWindow.open(_systemWindowContent, "gpsSystemWindowPos");								return;							}						}						distance = Math.sqrt(Math.pow(_lastCoords.x-entry.x, 2) + Math.pow(_lastCoords.y-entry.y, 2));						if(distance<distMin && distance > 0) {							index = i;							distMin = distance;						}					}										nearest = _data[index];					var label:String = Label.getLabel("gpsDirectionTemplate");					var dir:String;					label = label.replace(/\{X\}/gi, nearest.x);					label = label.replace(/\{Y\}/gi, nearest.y);					var north:Boolean	= nearest.y - _lastCoords.y < 0;					var isY:Boolean		= nearest.y != _lastCoords.y;					var west:Boolean	= nearest.x - _lastCoords.x < 0;					var isX:Boolean		= nearest.x != _lastCoords.x;					if(north && !isX && isY) dir = "n";					if(north && !west && isX && isY) dir = "ne";					if(!west && isX && !isY) dir = "e";					if(!north && !west && isX && isY) dir = "se";					if(!north && !isX && isY) dir = "s";					if(!north && west && isX && isY) dir = "sw";					if(west && isX && !isY) dir = "w";					if(north && west && isX && isY) dir = "nw";					label = label.replace(/\{DIRECTION\}/gi, dir);										label = label.replace(/\{PERCENT\}/gi, Math.round(index / _data.length * 100));										if(_data[currZoneIndex] != null){						raw = _data[currZoneIndex].rawData;					}else{						raw = null;					}					if(raw != null && raw.child("message") != undefined) {						label = label.replace(/\{COMMENTS\}/gi, "<br />«"+raw.child("message")+"»<br />");					}else{						label = label.replace(/\{COMMENTS\}/gi, "");					}					_systemWindowContent.populate(label, dir);					_systemWindow.open(_systemWindowContent, "gpsSystemWindowPos");					getZones(new Rectangle(_lastCoords.x, _lastCoords.y, _lastArea.width, _lastArea.height));				}else{					getZones(new Rectangle(_lastCoords.x, _lastCoords.y, _lastArea.width, _lastArea.height));				}			}		}										//__________________________________________________________ KPPP LOADING HANDLERS				/**		 * Called when KPP upload completes.		 */		private function uploadKppCompleteHandler(event:Event):void {			var loader:URLLoader = event.target as URLLoader;			var resultCode:int;			try{				var data:XML = new XML(loader.data);				resultCode = parseInt(data.child("result")[0]);			}catch(error:Error) {				resultCode = 100;			}			if(resultCode > 9 && resultCode < 100) resultCode = 100;			if(resultCode == 0) {				dispatchEvent(new GPSDataEvent(GPSDataEvent.UPLOAD_KPP_COMPLETE, 0, data.child("fileName")[0]));			}else{				dispatchEvent(new GPSDataEvent(GPSDataEvent.UPLOAD_KPP_ERROR, resultCode));			}		}				/**		 * Called if KPP upload fails.		 */		private function uploadKppErrorHandler(event:IOErrorEvent):void {			dispatchEvent(new GPSDataEvent(GPSDataEvent.UPLOAD_KPP_ERROR, 101));		}				/**		 * Called when KPP download completes.		 */		private function downloadKppCompleteHandler(event:Event):void {			var isError:Boolean;			var target:URLLoader = event.target as URLLoader;			try {				parsePathData(ByteArray(target.data).readObject());			}catch(error:Error) {				isError = true;			}			if(!isError) {				dispatchEvent(new GPSDataEvent(GPSDataEvent.DOWNLOAD_KPP_COMPLETE, 0));			}else{				dispatchEvent(new GPSDataEvent(GPSDataEvent.DOWNLOAD_KPP_COMPLETE, 1));			}		}		/**		 * Called if KPP download fails.		 */		private function downloadKppErrorHandler(event:IOErrorEvent):void {			dispatchEvent(new GPSDataEvent(GPSDataEvent.DOWNLOAD_KPP_ERROR, 101));		}
	}}internal class SingletonEnforcer{}
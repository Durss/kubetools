package com.muxxu.kube.crypto {	import flash.errors.IllegalOperationError;	/**	 * Provides methods to encrypt and decrypt strings.	 * 	 * @author  Francois	 */	public class ATL1 {				private static var CHARS:Array = ["ϴ","Ͼ","Ԏ","₪","Д","⌂","ᴪ","≡","≈","∩","⁞","ᴧ","◘","ᴨ","╔","╕","∆","Ω","●","◙","◌","◊","⸗","ⱴ","∂","‖","ג","ם","מ","ԓ","¤","¬","±","ƛ","ƣ","ʄ"];		private static var CHAR_TO_INDEX:Array = [];		private static var INITIALIZED:Boolean;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * @private		 */		public function ATL1() {			throw new IllegalOperationError("Use static members");		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/* ****** *		 * PUBLIC *		 * ****** */		public static function encode(src:String):String {			initialize();			var i:int, lenI:int, j:int, lenJ:int, k:int, res:String, codeStr:String, code:int;			lenI = src.length;			res = "";			for(i = 0; i < lenI; ++i) {				//If new line, skip it.				if(src.charAt(i) == "\n" || src.charAt(i) == "\r") {					res += "\n";					continue;				}				//Gets the current char code as a string				codeStr = src.charCodeAt(i).toString();				lenJ = codeStr.length;				//Generate the correspondance of the current char in Atlante char.				//Let's say the current char is "z".				//It's char code is 122. The loops will check first if an Atlante char				//exists in the "chars" array at the index 122. If not it will try with				//the index 12, and if not with the index 1. Then it will do the same thing				//with the rest of the car code. Si it will check if char exist at the index				//22, and if not, at the index 2. And the last char index will be 2.				//The current char's equivalent will be the concatenation of all the				//chars fount.				for(j = 0; j < lenJ;) {					k = lenJ + 1;					do {						k --;						code = parseInt(codeStr.substring(j, k));					} while(code > CHARS.length - 1 && k > 0);					j += k-j;					res += CHARS[code];				}				if(i < lenI - 1) res += " ";			}			return res;		}
		public static function decode(src:String):String {			initialize();			var i:int, lenI:int, j:int, lenJ:int, res:String, localChars:Array, code:String, currCode:String;			//Create an array with one entry per final char.			src = src.replace(/(\xD|\xA)/gi, " \n ");			localChars = src.split(/ /gi);			lenI = localChars.length;			res = "";			//Loop over all the chars			for(i = 0; i < lenI; ++i) {				//If the char is a line break, do not convert it. Add a line break.				if(String(localChars[i]).charCodeAt(0) == 13 || String(localChars[i]).charCodeAt(0) == 10){					res += "\n";					continue;				}								if(isNaN(String(localChars[i]).charCodeAt(0)) || String(localChars[i]).length == 0) continue;								lenJ = String(localChars[i]).length;				code = "";				//Retreive the complete char code of the current char from the Atlante chars.				for(j = 0; j < lenJ; ++j) {					currCode = CHAR_TO_INDEX[String(localChars[i]).charAt(j)];					if(currCode == null) {						if(!isNaN(parseInt(code))){							res += String.fromCharCode(parseInt(code));						}						res += String(localChars[i]).charAt(j);						code = "";					} else {						code += currCode;					}				}				//Get the char from its concatenated code.				res += String.fromCharCode(parseInt(code));			}			return res;		}						/* ******* *		 * PRIVATE *		 * ******* */		private static function initialize():void {			if(INITIALIZED) return;			INITIALIZED = true;						var i:int, len:int;			len = CHARS.length;			for(i = 0; i < len; ++i) {				if(CHAR_TO_INDEX[CHARS[i]] != null) {					trace("DOUBLON :: " + CHARS[i] + " at "+i);				}				CHAR_TO_INDEX[CHARS[i]] = i;			}		}			}}
package com.muxxu.kube.utils {	import uk.co.soulwire.display.colour.ColourUtils;	import flash.display.BitmapData;	import flash.geom.Rectangle;	/**	 * Singleton ImagePixelliser	 * 	 * @author Francois	 */	public class ImagePixelliser {				private var _sources:Vector.<uint>;		private var _paletteBitmapSource:Vector.<BitmapData>;		private var _colorsMax:Number;		private var _renderingPalette:Array;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>ImagePixelliser</code>.<br>		 */		public function ImagePixelliser() { }						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets bitmaps sources to use as pixelisation palette.<br>		 * <br>		 * The entries given in arguments will be used as pixels for the pixelated		 * image. The algorythm will compute the color average of each BitmapData		 * and match these values on the image to pixelate.		 */		public function set paletteBitmapSource(value:Vector.<BitmapData>):void {			var i:int, len:int;			_sources				= new Vector.<uint>();			_paletteBitmapSource	= value;			len						= value.length;			for(i = 0; i < len; ++i) {				_sources.push(ColorFunctions.bitmapDataAverage(value[i], 1, value[i].rect));			}		}		/**		 * Sets colors to use as pixelisation palette.		 */		public function set paletteSource(value:Vector.<uint>):void { _sources = value; }				/**		 * Gets the bitmaps sources used for pixelisation.		 */		public function get paletteBitmapSource():Vector.<BitmapData> { return _paletteBitmapSource; }		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Pixelate an image.<br>		 * <br>		 * The algorythme takes the <code>image</code> parameter and converts it		 * to a matrix of <code>sources</code> entries of image.width/pixelSize		 * columns and image.height/pixelSize rows.		 * 		 * @param image			image to pixelate.		 * @param pixelSize		pixels sizes.		 * @param flattenRatio	the more this value is near of 1, the less diffent colors will be used.		 */		public function pixelate(image:BitmapData, pixelSize:int, colorsMax:int):Array {			_renderingPalette = [];			_colorsMax = colorsMax;			var x:int, lenX:int, y:int, lenY:int, ret:Array, avg:Number;			lenX = image.width / pixelSize;			lenY = image.height / pixelSize;			ret = [];						createPalette(image);						//Get colors.			for(y = 0; y < lenY; ++y) {				ret[y] = [];				for(x = 0; x < lenX; ++x) {					avg = ColorFunctions.bitmapDataAverage(image, 1, new Rectangle(x * pixelSize, y * pixelSize, pixelSize, pixelSize));					//If the alpha average is too low, just skip the pixel.					if((avg >> 24 & 0xFF) < 0xC0){						ret[y][x] = -1;					}else{						ret[y][x] = getNearestColorIndex(avg);					}				}			}			return ret;		}						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Gets the nearest color, in the defined palette, of the color given in arguments.		 * 		 * @param color		the color to get the nearest color's index of.		 * 		 * @return the nearest color found.		 */		private function getNearestColorIndex(color:Number):int {			var i:int, len:int, ret:int, dist:Number, distMin:Number = Number.MAX_VALUE;			len = _renderingPalette.length;			for(i = 0; i < len; ++i) {				dist = ColorFunctions.getDistanceBetweenColors(ColorRelation(_renderingPalette[i]).color, color);				if(dist < distMin) {					distMin = dist;					ret = ColorRelation(_renderingPalette[i]).textureIndex;				}			}			return ret;		}				/**		 * Creates a palette containing only the dominant colors.		 * 		 * @param source bitmapData to get the dominant colors.		 */		private function createPalette(source:BitmapData):void {			var i:int, j:int, lenJ:int, len:int, ret:int, dist:Number, distMin:Number;			var colors:Array = ColourUtils.colourPalette(source, _colorsMax);			_renderingPalette = [];			len = colors.length;			lenJ = _sources.length;			for(i = 0; i < len; ++i) {				distMin = Number.MAX_VALUE;				for(j = 0; j < lenJ; ++j) {					dist = ColorFunctions.getDistanceBetweenColors(_sources[j], colors[i]);					if(dist < distMin) {						distMin = dist;						ret = j;					}				}				_renderingPalette.push(new ColorRelation(ret, colors[i]));			}		}	}}internal class ColorRelation {	private var _textureIndex:int;	private var _color:uint;	public function ColorRelation(textureIndex:int, color:uint) {		_color = color;		_textureIndex = textureIndex;	}		public function get color():uint {		return _color;	}		public function get textureIndex():int {		return _textureIndex;	}}
package com.muxxu.kube.views.gallery.results {	import gs.TweenLite;	import com.muxxu.kube.components.LoaderSpinning;	import com.muxxu.kube.components.form.VoteBar;	import com.muxxu.kube.data.GalleryData;	import com.muxxu.kube.vo.GalleryItem;	import com.nurun.components.bitmap.ImageResizer;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.filters.DropShadowFilter;	/**	 * Displays a gallery item.	 * 	 * @author  Francois	 */	public class GalleryResultItem extends ImageResizer {				private var _spin:LoaderSpinning;		private var _frame:Shape;		private var _error:Boolean;		private var _details:GalleryResultItemDetails;		private var _hit:Sprite;		private var _data:GalleryItem;		private var _canEnlarge:Boolean;		private var _autoSize:Boolean;
		private var _maxW:int;
		private var _maxH:int;		private var _thumbnailMode:Boolean;
						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>GalleryResultItem</code>.		 */		public function GalleryResultItem(canEnlarge:Boolean = true, align:String = null, resample:Boolean = true, mask:Boolean = false, w:int = 0, h:int = 0) {			_canEnlarge = canEnlarge;			super(align, resample, mask, w, h);		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */								/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Populates the item.		 */		public function populate(data:GalleryItem, thumbnailMode:Boolean = false):void {			_thumbnailMode = thumbnailMode;			_data = data;			_image.bitmapData = null;			load(_thumbnailMode? _data.icon : _data.image);			_details.populate(_data);			_spin.open();			_error = false;			computePositions();		}				/**		 * Sets the autosize mode.<br>		 * <br>		 * When the autosize mode is set, the component is resized with the		 * loaded image's sizes.		 */		public function setAutoSizeMode():void {			_autoSize = true;		}				/**		 * Sets the maximum sizes of the image.		 */		public function setMaxSizes(w:Number, h:Number):void {			_maxW = w;			_maxH = h;			_width = Math.min(_maxW, defaultWidth);			_height = Math.min(_maxH, defaultHeight);			computePositions();		}				/**		 * Just catch IO error. A bit dirty...		 */		override public function dispatchEvent(event:Event):Boolean {			if(event.type == IOErrorEvent.IO_ERROR) return false;			return super.dispatchEvent(event);		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		override protected function initialize():void {			super.initialize();						_hit	= addChild(new Sprite()) as Sprite;			_spin	= addChild(new LoaderSpinning()) as LoaderSpinning;			_details= addChild(new GalleryResultItemDetails()) as GalleryResultItemDetails;			_frame	= addChild(new Shape()) as Shape;						_maxW = int.MAX_VALUE;			_maxH = int.MAX_VALUE;						_details.alpha	= 0;			_details.visible= false;			_hit.buttonMode = _canEnlarge;			_spin.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 1, 3)];						addEventListener(MouseEvent.ROLL_OVER,	rollOverHandler);			addEventListener(MouseEvent.ROLL_OUT,	rollOutHandler);			if(_canEnlarge) {				addEventListener(MouseEvent.CLICK,	clickHandler);			}			_loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,	loadErrorHandler);		}		/**		 * Resize and replace the elements.		 */		override protected function computePositions():void {			super.computePositions();						var margins:int = 5;			_spin.x			= Math.round(_width * .5) + margins;			_spin.y			= Math.round(_image.y + _height * .5);						_details.width	= _width;			_details.height	= _height;						_frame.graphics.clear();			_frame.graphics.lineStyle(1, 0x2E7D9E, 1);			_frame.graphics.drawRect(0, 0, _width, _height);						if(_canEnlarge) {				_hit.graphics.clear();				_hit.graphics.beginFill(0, 0);				if(_error){					_hit.graphics.beginFill(0xCC0000, 1);				}				_hit.graphics.drawRect(0, 0, _width, _height);			}						graphics.clear();			graphics.beginFill(0xffffff, 1);			graphics.drawRect(0, 0, _width, _height);		}														//__________________________________________________________ MOUSE EVENTS		/**		 * Called when the component is rolled over.		 */		private function rollOverHandler(e:MouseEvent):void {			_details.populate(_data);			TweenLite.to(_details, .5, {autoAlpha:1});			if(_canEnlarge) {				TweenLite.to(this, .5, {dropShadowFilter:{blurX:20, blurY:20, distance:0, alpha:.5, strength:1, color:0}});				parent.addChild(this);			}		}		/**		 * Called when the component is rolled out.		 */		private function rollOutHandler(e:MouseEvent):void {			TweenLite.to(_details, .25, {autoAlpha:0});			if(_canEnlarge) {				TweenLite.to(this, .4, {dropShadowFilter:{burX:0, blurY:0, alpha:0, remove:true}});			}		}		/**		 * Called when the component is clicked.		 */		private function clickHandler(e:MouseEvent):void {			if(e.target is VoteBar) return;			GalleryData.getInstance().enlargeItem(_data.index);		}										//__________________________________________________________ LOADING EVENTS				/**		 * Called when image loading completes		 */		override protected function loadCompleteHandler(e:Event):void {			if(_autoSize) {				_width = Math.min(_maxW, defaultWidth);				_height = Math.min(_maxH, defaultHeight);			}			_spin.close();			_error = false;			super.loadCompleteHandler(e);		}		/**		 * Called if an error occurs on image loading.		 */		override protected function loadErrorHandler(e:IOErrorEvent):void {			_spin.close();			_error = true;			computePositions();		}
	}}
package com.muxxu.kube.views.generator.selector {	import com.muxxu.kube.components.Separator;	import com.muxxu.kube.components.form.KubeRadioButton;	import com.muxxu.kube.components.form.TextureEnablerButton;	import com.muxxu.kube.controler.FrontControler;	import com.muxxu.kube.data.TexturesData;	import com.muxxu.kube.events.KTModelEvent;	import com.muxxu.kube.views.AbstractKTView;	import com.muxxu.kube.vo.Message;	import com.muxxu.kube.vo.MessageIds;	import com.muxxu.kube.vo.SeparatorType;	import com.muxxu.kube.vo.Templates;	import com.muxxu.kube.vo.Texture;	import com.nurun.components.form.FormComponentGroup;	import com.nurun.components.form.events.FormComponentGroupEvent;	import com.nurun.structure.environnement.label.Label;	import com.nurun.structure.mvc.model.events.IModelEvent;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * Displays the kube selector displayed at the bottom of the screen when the generator is opened	 * 	 * @author  Francois	 */	public class TextureSelector extends AbstractKTView {				private var _separator:Separator;		private var _upRb:KubeRadioButton;		private var _sideRb:KubeRadioButton;		private var _bottomRb:KubeRadioButton;		private var _rbGroup:FormComponentGroup;		private var _texturesCtn:Sprite;		private var _cubes:Vector.<TextureCube>;		private var _cubeGroup:FormComponentGroup;		private var _enablersCollection:Vector.<TextureEnablerButton>;		private var _enablersContainer:Sprite;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>TextureSelector</code>.		 */		public function TextureSelector() {			super();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		override public function get height():Number { return _pane.y + _height; }						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Called when model's state changes		 */		override public function update(e:IModelEvent):void {			var message:Message = KTModelEvent(e).message;			alpha = 1;						if(_cubes == null) {				_cubes = new Vector.<TextureCube>();				var i:int, len:int, textures:Vector.<Texture>, cube:TextureCube, enabler:TextureEnablerButton;				len = TexturesData.getInstance().length;				textures = TexturesData.getInstance().textures;								for(i = 0; i < len; ++i) {					if(textures[i].id == "61") continue;					enabler	= new TextureEnablerButton(textures[i]);					cube	= new TextureCube();					cube.populate(textures[i]);					_cubes.push(cube);					_cubeGroup.add(cube);					_enablersCollection.push(enabler);				}				_enablersContainer.visible = false;				updateCollection();			}						if(message.id == MessageIds.DISPLAY_TOOLS_IMAGE) {				_enablersContainer.visible = true;			}else if(MessageIds.isToolBoxMessage(message.id) || message.id == MessageIds.SUBMIT_IMAGE_PARAMS || message.id == MessageIds.CLOSE_TOOLBOX) {				_enablersContainer.visible = false;			}						if(message.id == MessageIds.CHANGE_VIEW){				visible = message.data == Templates.GENERATOR;			}						var contains:Boolean = contains(_texturesCtn);			if(!visible && contains) {				removeChild(_texturesCtn);			}else if(!contains){				addChild(_texturesCtn);			}		}						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		override protected function initialize():void {			super.initialize();						_rbGroup = new FormComponentGroup();			_cubeGroup	= new FormComponentGroup();			_enablersCollection = new Vector.<TextureEnablerButton>();						_separator	= addChildOutsidePane(new Separator(SeparatorType.HORIZONTAL)) as Separator;			_upRb		= addChild(new KubeRadioButton(Label.getLabel("upRB"), _rbGroup)) as KubeRadioButton;			_sideRb		= addChild(new KubeRadioButton(Label.getLabel("sideRB"), _rbGroup)) as KubeRadioButton;			_bottomRb	= addChild(new KubeRadioButton(Label.getLabel("bottomRB"), _rbGroup)) as KubeRadioButton;			_texturesCtn= new Sprite();			_enablersContainer = new Sprite();						_sideRb.selected = true;			_rbGroup.addEventListener(FormComponentGroupEvent.CHANGE,	changeSelectionHandler);			_cubeGroup.addEventListener(FormComponentGroupEvent.CHANGE,	changeCubeHandler);		}		/**		 * Resize and replace the elements.		 */		override protected function computePositions(e:Event = null):void {			_pane.y			= _separator.height + 2;			_upRb.x			= 5;			_sideRb.x		= Math.round(_upRb.x + _upRb.width + 10);			_bottomRb.x		= Math.round(_sideRb.x + _sideRb.width + 10);			_texturesCtn.y	= Math.round(_upRb.y + _upRb.height) + 5;			_separator.width= _width;			super.computePositions();		}				/**		 * Updates the textures collection.		 */		private function updateCollection():void {			var selectedItem:KubeRadioButton = _rbGroup.selectedItem as KubeRadioButton;			while(_texturesCtn.numChildren > 0) { _texturesCtn.removeChildAt(0); }			var i:int, len:int, px:int, py:int, textures:Vector.<Texture>, cube:TextureCube, exCube:TextureCube, exLandScapeId:String, exZonePos:Point, rect:Rectangle, enabler:TextureEnablerButton;			len = _cubes.length;			textures = TexturesData.getInstance().textures;						for(i = 0; i < len; ++i) {				cube = _cubes[i];				_texturesCtn.addChild(cube);				_enablersContainer.addChild(_enablersCollection[i]);				if(selectedItem == _upRb) {					cube.showTop();				}else if(selectedItem == _sideRb) {					cube.showSide();				}else if(selectedItem == _bottomRb) {					cube.showBottom();				}			}			_texturesCtn.addChild(_enablersContainer);						px = 10;			_texturesCtn.graphics.clear();			for(i = 0; i < len; ++i) {				cube = _cubes[i];				enabler = _enablersCollection[i];				if(px > ((cube.width+5) * len) * .5 && cube.texture.landScapeID != exLandScapeId) {					px = 10;					py += cube.height + 20;				}				cube.x = px;				cube.y = py;				px += cube.width + 5;								if(exLandScapeId != null && (cube.texture.landScapeID != exLandScapeId || i == len - 1)){					rect = new Rectangle();					rect.x = exZonePos.x + - 4;					rect.y = exZonePos.y + - 4;					rect.width = exCube.x + exCube.width - exZonePos.x + 8;					rect.height = exCube.height + 8;					if(i == len - 1){						rect.width += exCube.width + 5;					}										_texturesCtn.graphics.beginFill(0xFFFFFF, .2);					_texturesCtn.graphics.drawRoundRect(rect.x, rect.y, rect.width, rect.height, 6);					_texturesCtn.graphics.endFill();					if(px > 10 + cube.width + 5 && i < len - 1){						cube.x += 10;						px += 10;					}				}				if(exZonePos == null || cube.texture.landScapeID != exLandScapeId) {					exZonePos = new Point(cube.x, cube.y);				}								enabler.x = Math.round(cube.x + (cube.width - enabler.width) * .5);				enabler.y = Math.round(cube.y + cube.height + 4);								exCube = cube;				exLandScapeId = cube.texture.landScapeID;			}						//As all the content is moved from 5px to the right, when the			//scrollpan checks the width of the content, it only gets the real			//width without this 5px margin. And this is source of a shift of			//5px on the max horizontal scroll. This rect is here to help the			//scrollpane to do the correct calculations. 			_texturesCtn.graphics.endFill();			_texturesCtn.graphics.beginFill(0xFF0000, 0);			_texturesCtn.graphics.drawRect(0, 0, _texturesCtn.width + 10, 5);						computePositions();		}										//__________________________________________________________ EVENTS HANDLERS				/**		 * Called when a new radio button is selected.		 */		private function changeSelectionHandler(e:FormComponentGroupEvent):void {			updateCollection();			if(_cubeGroup.selectedItem != null){				changeCubeHandler();			}			FrontControler.getInstance().sendMessage(MessageIds.UPDATE_GRID);		}		/**		 * Called when a new cube is selected.		 */		private function changeCubeHandler(e:FormComponentGroupEvent = null):void {			FrontControler.getInstance().texture = TextureCube(_cubeGroup.selectedItem).texture;		}	}}
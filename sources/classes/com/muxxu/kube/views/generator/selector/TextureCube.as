package com.muxxu.kube.views.generator.selector {	import gs.TweenLite;	import gs.easing.Sine;	import com.muxxu.kube.components.tooltip.content.TTLandScapeContent;	import com.muxxu.kube.controler.FrontControler;	import com.muxxu.kube.vo.Texture;	import com.muxxu.kube.vo.ToolTipMessage;	import com.nurun.components.button.AbstractNurunButton;	import com.nurun.components.button.events.NurunButtonEvent;	import com.nurun.components.form.GroupableFormComponent;	import com.nurun.components.volume.Cube;	import flash.display.Bitmap;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.filters.GlowFilter;	import flash.geom.PerspectiveProjection;	import flash.geom.Point;	import flash.utils.Timer;	/**	 * Displays a texture cube.<br/>	 * <br/>	 * The cube's can be rolled over to rotate it.	 * 	 * @author  Francois	 */	public class TextureCube extends AbstractNurunButton implements GroupableFormComponent {				private static var _currentTarget:TextureCube;				private const WIDTH:int		= 32;		private const HEIGHT:int	= 32;		private const DEPTH:int		= 32;		private var _cube:Cube;		private var _bottom:TextureCubeFace;		private var _top:TextureCubeFace;		private var _back:TextureCubeFace;		private var _front:TextureCubeFace;		private var _right:TextureCubeFace;		private var _left:TextureCubeFace;		private var _defaultRX:int;		private var _endRX:Number;		private var _endRY:Number;		private var _texture:Texture;		private var _selected:Boolean;		private var _width:Number;		private var _height:Number;		private var _depth:Number;		private var _timerToolTip:Timer;										/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>TextureCube</code>.		 */		public function TextureCube() {			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets the cube's width.		 */		override public function set width(value:Number):void {			_width = value;			computePositions();		}				/**		 * Sets the cube's height.		 */		override public function set height(value:Number):void {			_height = value;			computePositions();		}				/**		 * Sets the cube's depth.		 */		public function set depth(value:Number):void {			_depth = value;			computePositions();		}						/**		 * Gets the theorical cube's width.		 */		override public function get width():Number { return isNaN(_width)? WIDTH : _width; }		/**		 * Gets the theorical cube's height.		 */		override public function get height():Number { return isNaN(_height)? HEIGHT : _height; }		/**		 * Gets the theorical cube's depth.		 */		public function get depth():Number { return isNaN(_depth)? DEPTH : _depth; }				/**		 * Gets if the cube is selected or not.		 */		public function get selected():Boolean { return _selected; }				/**		 * Sets if the cube is selected or not.		 */		public function set selected(value:Boolean):void {			if(value){				select();			}else{				unSelect();			}			dispatchEvent(new Event(Event.CHANGE));		}		/**		 * Gets the <code>Texture</code> value object associated to the cube.		 */		public function get texture():Texture { return _texture; }						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Sets the cube's faces images.		 */		public function populate(texture:Texture):void {			_texture		= texture;			_top.bitmap		= new Bitmap(_texture.top);			_left.bitmap	= new Bitmap(_texture.side);			_right.bitmap	= new Bitmap(_texture.side);			_front.bitmap	= new Bitmap(_texture.side);			_back.bitmap	= new Bitmap(_texture.side);			_bottom.bitmap	= new Bitmap(_texture.bottom);		}		/**		 * Shows the top face of the cube.		 */		public function showTop():void {			_texture.selectTop();			_defaultRX = 90;			TweenLite.to(_cube, .5, {shortRotation:{rotationX:_defaultRX, rotationY:0, rotationZ:0}, ease:Sine.easeInOut, onComplete:_cube.removeMatrices});		}				/**		 * Shows the front face of the cube.		 */		public function showSide():void {			_texture.selectSide();			_defaultRX = 0;			TweenLite.to(_cube, .5, {shortRotation:{rotationX:_defaultRX, rotationY:0, rotationZ:0}, ease:Sine.easeInOut, onComplete:_cube.removeMatrices});		}				/**		 * Shows the bottom face of the cube.		 */		public function showBottom():void {			_texture.selectBottom();			_defaultRX = -90;			TweenLite.to(_cube, .5, {shortRotation:{rotationX:_defaultRX, rotationY:0, rotationZ:0}, ease:Sine.easeInOut, onComplete:_cube.removeMatrices});		}				/**		 * Called to select the component.		 */		public function select():void {			_selected = true;			_cube.filters = [new GlowFilter(0xFFFFFF, 1, 3, 3, 5, 3)];		}				/**		 * Called to unselect the component.		 */		public function unSelect():void {			_selected = false;			_cube.filters = [];		}				/**		 * Makes the component garbage collectable.		 */		override public function dispose():void {			super.dispose();			while(numChildren > 0){ removeChildAt(0); }						removeEventListener(Event.ENTER_FRAME,		rotateCube);			removeEventListener(NurunButtonEvent.OVER,	customRollOverHandler);			removeEventListener(NurunButtonEvent.OUT,	customRollOutHandler);			removeEventListener(MouseEvent.ROLL_OUT,	customRollOutHandler);			removeEventListener(NurunButtonEvent.PRESS,	pressHandler);			removeEventListener(NurunButtonEvent.RELEASE, releaseHandler);			removeEventListener(NurunButtonEvent.RELEASE_OUTSIDE, releaseOutsideHandler);						_cube.transform.perspectiveProjection = null;			_cube.dispose();			_left.dispose();			_right.dispose();			_front.dispose();			_back.dispose();			_top.dispose();			_bottom.dispose();						if(_currentTarget == this) _currentTarget = null;			_cube	= null;			_left	= null;			_right	= null;			_front	= null;			_back	= null;			_top	= null;			_bottom	= null;			_texture= null;		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		private function initialize():void {			_cube				= addChild(new Cube()) as Cube;			_cube.leftFace		= _left		= new TextureCubeFace();			_cube.rightFace		= _right	= new TextureCubeFace();			_cube.frontFace		= _front	= new TextureCubeFace();			_cube.backFace		= _back		= new TextureCubeFace();			_cube.topFace		= _top		= new TextureCubeFace();			_cube.bottomFace	= _bottom	= new TextureCubeFace();						_timerToolTip		= new Timer(250, 1);			_timerToolTip.addEventListener(TimerEvent.TIMER_COMPLETE, openToolTipHandler);						mouseChildren		= false;			buttonMode			= true;			addEventListener(Event.ADDED_TO_STAGE,		addedToStageHandler);			addEventListener(NurunButtonEvent.OVER,		customRollOverHandler);			addEventListener(NurunButtonEvent.OUT,		customRollOutHandler);			addEventListener(MouseEvent.ROLL_OUT,		customRollOutHandler);			addEventListener(NurunButtonEvent.PRESS,	pressHandler);			addEventListener(NurunButtonEvent.RELEASE,	releaseHandler);			addEventListener(NurunButtonEvent.RELEASE_OUTSIDE, releaseOutsideHandler);						var perspective:PerspectiveProjection = new PerspectiveProjection();			perspective.projectionCenter = new Point(0, 0);			perspective.fieldOfView = 1;			_cube.transform.perspectiveProjection = perspective;			computePositions();		}				override protected function addedToStageHandler(event:Event):void {			super.addedToStageHandler(event);			_cube.removeMatrices();		}		/**		 * Resizes and replaces the cube.		 */		private function computePositions():void {			_cube.width			= width;			_cube.height		= height;			_cube.depth			= depth;			_cube.x				= Math.round(width * .5);			_cube.y				= Math.round(height * .5);		}		/**		 * Rotate the cube.		 */		private function rotateCube(e:Event = null):void {			if(_currentTarget != null){				var d:Number = Math.sqrt(Math.pow(mouseX - _cube.x, 2) + Math.pow(mouseY - _cube.y, 2));				if(d > 16) {					_endRX -= (mouseY - 16) * .1;					_endRY += (mouseX - 16) * .1;				}				_cube.rotationX	+= (_endRX - _cube.rotationX) * .2;				_cube.rotationY	+= (_endRY - _cube.rotationY) * .2;			}else{				_cube.rotationX += 3;				_cube.rotationY -= 6;				_endRX = _cube.rotationX;				_endRY = _cube.rotationY;			}		}				/**		 * Called after a delay to open the tooltip.		 */		private function openToolTipHandler(e:TimerEvent):void {			if(_texture.landScapeURL != null){				FrontControler.getInstance().openToolTip(new ToolTipMessage(new TTLandScapeContent(_texture.landScapeURL, .5), this));			}		}														//__________________________________________________________ MOUSE EVENTS				/**		 * Called when the cube is pressed.		 */		private function pressHandler(e:NurunButtonEvent):void {			_currentTarget = this;		}				/**		 * Called when the cube is released.		 */		private function releaseHandler(e:NurunButtonEvent):void {			customRollOverHandler(e);			if(_currentTarget == this) {				dispatchEvent(new Event(Event.CHANGE));			}			_currentTarget = null;		}				/**		 * Called when the button is released outside.		 */		private function releaseOutsideHandler(e:NurunButtonEvent):void {			if(_currentTarget == this) _currentTarget = null;			customRollOutHandler(e);		}		/**		 * Called when the cube is rolled over.		 */		private function customRollOverHandler(e:NurunButtonEvent):void {			_timerToolTip.reset();			_timerToolTip.start();			parent.addChild(this);//Bring to front			TweenLite.killTweensOf(_cube);			TweenLite.to(this, .5, {dropShadowFilter:{blurX:5, blurY:5, distance:10, angle:90, color:0, alpha:.3, strength:2, quality:3}});			addEventListener(Event.ENTER_FRAME, rotateCube);						//Circle bounds for mouse hit.			//The cube's faces are not always perfectly touching and so a roll out			//event can be fired if the mouse is between two faces. To prevent			//from that, a circle is drawn behind the cube during its rotation.			graphics.clear();			graphics.beginFill(0xFF0000, 0);			graphics.drawCircle(width * .5, height * .5, width * .5 + 10);		}		/**		 * Called when the cube is rolled out.		 */		private function customRollOutHandler(e:Event = null):void {			_timerToolTip.reset();			_timerToolTip.stop();			if(e is NurunButtonEvent) {				if(!hasEventListener(Event.ENTER_FRAME) || _currentTarget == this) return;				removeEventListener(Event.ENTER_FRAME, rotateCube);				TweenLite.to(_cube, .5, {shortRotation:{rotationX:_defaultRX, rotationY:0, rotationZ:0}, onComplete:_cube.removeMatrices});				TweenLite.to(this, .5, {dropShadowFilter:{blurX:20, blurY:20, alpha:0, quality:0, remove:true}});			}						graphics.clear();		}	}}
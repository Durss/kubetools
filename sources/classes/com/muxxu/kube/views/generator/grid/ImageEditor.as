package com.muxxu.kube.views.generator.grid {	import com.muxxu.kube.metrics.GeneratorGridMetrics;
	import gs.TweenLite;	import com.muxxu.kube.controler.FrontControler;	import com.muxxu.kube.vo.Message;	import com.muxxu.kube.vo.MessageIds;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.ui.Keyboard;	import flash.ui.Mouse;	import flash.ui.MouseCursor;	/**	 * Displays a loaded image and provides to scale and move it.	 * 	 * @author  Francois	 */	public class ImageEditor extends Sprite {				private const TOP_LEFT:String		= "tl";		private const TOP_RIGHT:String		= "tr";		private const BOTTOM_LEFT:String	= "bl";		private const BOTTOM_RIGHT:String	= "br";		private const HANDLE_SIZE:int		= 10;				private var _width:Number;		private var _height:Number;		private var _image:Bitmap;		private var _stage:Stage;		private var _pressed:Boolean;		private var _dragOffset:Point;		private var _mask:Shape;		private var _drawCtn:Sprite;		private var _handles:Sprite;		private var _dragCorner:Point;		private var _cornerType:String;								/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>ImageEditor</code>.		 */		public function ImageEditor() {			initialize();			addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets the component's width without simply scaling it.		 */		override public function set width(value:Number):void {			_width = value;			computePositions();		}				/**		 * Sets the component's height without simply scaling it.		 */		override public function set height(value:Number):void {			_height = value;			computePositions();		}				/**		 * Gets the virtual component's width.		 */		override public function get width():Number { return _width; }				/**		 * Gets the virtual component's hright.		 */		override public function get height():Number { return _height; }		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Called when model's state changes		 */		public function update(message:Message):void {			if(message.id == MessageIds.IMAGE_LOADED) {				mouseEnabled	= true;				mouseChildren	= true;				_image.bitmapData = message.data as BitmapData;				_image.scaleX	= _image.scaleY = 1;				_handles.visible = true;								var newSize:Number;				//If image's sizes are smaller than the grid, just multiply the dimensions				//by the cell sizes.				if(_image.width <= GeneratorGridMetrics.COLS + 5 && _image.height <= GeneratorGridMetrics.ROWS + 5) {					_image.width	*= GeneratorGridMetrics.CELL_WIDTH;					_image.height	*= GeneratorGridMetrics.CELL_HEIGHT;								//Else, if the image's sizes are less than ten times the number of rows and cols,				//just fit the image to the grid.				}else if(_image.width <= GeneratorGridMetrics.COLS * 10 && _image.height <= GeneratorGridMetrics.ROWS * 10) {					if(_image.width > _image.height){						newSize			= GeneratorGridMetrics.CELL_WIDTH * GeneratorGridMetrics.COLS;						_image.height	*= newSize / _image.width;						_image.width	= newSize;					}else{						newSize			= GeneratorGridMetrics.CELL_HEIGHT * GeneratorGridMetrics.ROWS;						_image.width	*= newSize / _image.height;						_image.height	= newSize;					}				//Else, just resize the image to make it snap to the nearest grid's cells.				}else if(_image.width > _image.height) {					newSize			= Math.round(_image.width / GeneratorGridMetrics.CELL_WIDTH) * GeneratorGridMetrics.CELL_WIDTH;					_image.height	*= _image.width / newSize;					_image.width	= newSize; 				} else{					newSize			= Math.round(_image.height / GeneratorGridMetrics.CELL_HEIGHT) * GeneratorGridMetrics.CELL_HEIGHT;					_image.width	*= _image.height / newSize;					_image.height	= newSize; 				}								//round the sizes just in case				_image.width = Math.round(_image.width);				_image.height = Math.round(_image.height);								_image.x = Math.floor((_width - _image.width) * .5);				_image.y = Math.floor((_height - _image.height) * .5);								drawBitmap();				drawHandles();				FrontControler.getInstance().sendMessage(MessageIds.DISPLAY_TOOLS_IMAGE);			}else if(MessageIds.isToolBoxMessage(message.id) && message.id != MessageIds.DISPLAY_TOOLS_IMAGE) {				stopEdition();			}		}						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		private function initialize():void {			_drawCtn	= addChild(new Sprite()) as Sprite;			_mask		= _drawCtn.addChild(new Shape()) as Shape;			_image		= _drawCtn.addChild(new Bitmap()) as Bitmap;			_handles	= addChild(new Sprite()) as Sprite;						mouseEnabled = false;			mouseChildren = false;			_width = _height = 100;						_handles.buttonMode = true;						_mask.graphics.beginFill(0xFF0000, 0);			_mask.graphics.drawRect(0, 0, 100, 100);			_image.mask = _mask;						addEventListener(MouseEvent.MOUSE_DOWN,	mouseDownHandler);			addEventListener(MouseEvent.MOUSE_UP,	mouseUpHandler);			addEventListener(MouseEvent.MOUSE_OVER,	rollOverHandler);			addEventListener(MouseEvent.MOUSE_OUT,	rollOutHandler);						rollOutHandler();			computePositions();		}		/**		 * Called when the stage is available.		 */		private function addedToStageHandler(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);			_stage = stage;			_stage.addEventListener(MouseEvent.MOUSE_UP,	mouseUpHandler);			_stage.addEventListener(MouseEvent.MOUSE_MOVE,	mouseMoveHandler);			_stage.addEventListener(KeyboardEvent.KEY_UP,	keyUpHandler);		}		/**		 * Resize and replace the elements.		 */		private function computePositions():void {			_mask.width = _width;			_mask.height = _height;						drawHandles();						//For mouse hit			graphics.clear();			graphics.beginFill(0x00FF00, 0);			graphics.drawRect(0, 0, _width, _height);		}				/**		 * Redraws the handles.		 */		private function drawHandles():void {			_handles.graphics.clear();			_handles.graphics.lineStyle(1, 0, 1);			_handles.graphics.drawRect(0, 0, _image.width, _image.height);			_handles.graphics.beginFill(0xFFFFFF, 1);			_handles.graphics.drawRect(0, 0, HANDLE_SIZE, HANDLE_SIZE);			_handles.graphics.drawRect(_image.width - HANDLE_SIZE, 0, HANDLE_SIZE, HANDLE_SIZE);			_handles.graphics.drawRect(_image.width - HANDLE_SIZE, _image.height - HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE);			_handles.graphics.drawRect(0, _image.height - HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE);						_handles.x = _image.x;			_handles.y = _image.y;		}		/**		 * Draws the current image and send it to the grid generator.		 */		private function drawBitmap():void {			if(_image.bitmapData == null) return;			var bmd:BitmapData = new BitmapData(_width, _height, true, 0);			bmd.draw(_drawCtn);			FrontControler.getInstance().setBitmapDataToDraw(bmd);		}				/**		 * Stops image edition		 */		private function stopEdition():void {			Mouse.cursor = MouseCursor.AUTO;			_handles.visible = false;			mouseChildren = mouseEnabled = false;			_image.bitmapData = null;		}										//__________________________________________________________ KEYBOARD EVENTS				/**		 * Called when a key is released.		 */		private function keyUpHandler(e:KeyboardEvent):void {			var cancel:Boolean = e.keyCode == Keyboard.DELETE || e.keyCode == Keyboard.ESCAPE;			if( (e.keyCode == Keyboard.ENTER || cancel) && _image.bitmapData != null) {				if(cancel) {					FrontControler.getInstance().sendMessage(MessageIds.CLEAR_GRID);				}else{					FrontControler.getInstance().sendMessage(MessageIds.SUBMIT_IMAGE_PARAMS);				}				stopEdition();				FrontControler.getInstance().sendMessage(MessageIds.CLOSE_TOOLBOX);			}		}												//__________________________________________________________ MOUSE EVENTS				/**		 * Called when the component is rolled over.		 */		private function rollOverHandler(e:MouseEvent = null):void {			if(e != null && e.target == _handles){				Mouse.cursor = MouseCursor.AUTO;			} else{				Mouse.cursor = MouseCursor.HAND;			} 			TweenLite.to(this, .5, {alpha:.5, overwrite:1});		}				/**		 * Called when the component is rolled out.		 */		private function rollOutHandler(e:MouseEvent = null):void {			if(_pressed) return;			TweenLite.to(this, .5, {alpha:0});			Mouse.cursor = MouseCursor.AUTO;		}		/**		 * Called when mouse is pressed.		 */		private function mouseDownHandler(e:MouseEvent):void {			_pressed = true;			_dragOffset = new Point(_image.mouseX * _image.scaleX, _image.mouseY * _image.scaleY);			if(e.target == _handles){				_cornerType = (_image.mouseY * _image.scaleY <= _image.height * .5) ? "t" : "b";				_cornerType += (_image.mouseX * _image.scaleX <= _image.width * .5)? "l" : "r";								if(_cornerType == TOP_LEFT){					_dragCorner = new Point(_image.x + _image.width, _image.y + _image.height);				}else if(_cornerType == TOP_RIGHT) {					_dragOffset.x = _image.width - _dragOffset.x;					_dragCorner = new Point(_image.x, _image.y + _image.height);				}else if(_cornerType == BOTTOM_RIGHT) {					_dragOffset.x = _image.width - _dragOffset.x;					_dragOffset.y = _image.height - _dragOffset.y;					_dragCorner = new Point(_image.x, _image.y);				}else if(_cornerType == BOTTOM_LEFT) {					_dragOffset.y = _image.height - _dragOffset.y;					_dragCorner = new Point(_image.x + _image.width, _image.y);				}			}		}		/**		 * Called when mouse is released.		 */		private function mouseUpHandler(e:MouseEvent):void {			if(!_pressed) return;			if(!hitTestPoint(_stage.mouseX, _stage.mouseY)){				rollOutHandler();			}			_dragCorner = null;			_pressed = false;			drawBitmap();		}		/**		 * Called when the mouse moves.		 */		private function mouseMoveHandler(e:MouseEvent):void {			if(!_pressed) return;			if(_dragCorner != null){				//_dragCorner contains the opposite dragged corner coordinates								//Resize image				_image.width	= Math.abs(mouseX + _dragOffset.x - _dragCorner.x);				_image.height	= Math.abs(mouseY + _dragOffset.y - _dragCorner.y);								//Restrict sizes if SHIFT key is pressed				if(e.shiftKey){					if(_image.scaleX > _image.scaleY){						_image.scaleX = _image.scaleY;					} else{						_image.scaleY = _image.scaleX;					}				}								if(e.ctrlKey){					_image.width = Math.round(_image.width / GeneratorGridMetrics.CELL_WIDTH) * GeneratorGridMetrics.CELL_WIDTH;					_image.height = Math.round(_image.height / GeneratorGridMetrics.CELL_HEIGHT) * GeneratorGridMetrics.CELL_HEIGHT;				}								//Set min sizes				if(_image.width < 32) _image.width = 32;				if(_image.height < 32) _image.height = 32;								//Replace image				_image.x = _dragCorner.x;								_image.y = _dragCorner.y;				if(_cornerType == TOP_LEFT || _cornerType == BOTTOM_LEFT) {					_image.x -= _image.width;								}				if(_cornerType == TOP_LEFT || _cornerType == TOP_RIGHT) {					_image.y -= _image.height;								}			} else{				_image.x = mouseX - _dragOffset.x;				_image.y = mouseY - _dragOffset.y;				if(e.ctrlKey) {					_image.x = Math.round(_image.x / GeneratorGridMetrics.CELL_WIDTH) * GeneratorGridMetrics.CELL_WIDTH;					_image.y = Math.round(_image.y / GeneratorGridMetrics.CELL_HEIGHT) * GeneratorGridMetrics.CELL_HEIGHT;				}				Mouse.cursor = MouseCursor.HAND;				var margin:int = 16;				if(_image.x < margin - _image.width)	_image.x = margin - _image.width;				if(_image.x > _width - margin)			_image.x = _width - margin;				if(_image.y < margin - _image.height)	_image.y = margin - _image.height;				if(_image.y > _height - margin)			_image.y = _height - margin;			}			drawHandles();		}	}}
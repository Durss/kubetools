package com.muxxu.kube.views.generator.toolbox {	import com.muxxu.kube.graphics.WindowBackground;	import com.muxxu.kube.vo.Message;	import com.muxxu.kube.vo.MessageIds;	import com.nurun.components.button.GraphicButton;	import com.nurun.components.button.events.NurunButtonEvent;	import com.nurun.components.text.CssTextField;	import com.nurun.utils.text.TextBounds;	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.DropShadowFilter;	import flash.geom.Rectangle;	/**	 * Displays the toolbox of the genrator template.	 * 	 * @author  Francois	 */	public class ToolBox extends Sprite {				private var _background:WindowBackground;		private var _cam:ToolsCam;		private var _images:ToolsImage;		private var _title:CssTextField;		private var _dragBar:GraphicButton;		private var _dragBounds:Rectangle;		private var _lastDisplayedContent:IToolBoxContent;		private var _stats:ToolsStats;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>Tools</code>.		 */		public function ToolBox() {			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets the drag bounds.		 */		public function set dragBounds(value:Rectangle):void { _dragBounds = value; computePositions(); }		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Called on model's update.		 */		public function update(message:Message):void {			var lastContent:IToolBoxContent	= _lastDisplayedContent;			_lastDisplayedContent			= null;			var oldDisplayState:Boolean		= visible;			var displayState:Boolean 		= updateContent(message, _images);			displayState					= updateContent(message, _cam) || displayState;			displayState					= updateContent(message, _stats) || displayState;						if(message.id == MessageIds.CLOSE_TOOLBOX) {				displayState = _images.visible = _cam.visible = _stats.visible = false;			}						if(oldDisplayState != displayState){				visible = displayState;			}			if(displayState && lastContent != _lastDisplayedContent) {				computePositions();			}		}				/**		 * Updates a content and returns if the content should be displayed or not.<br/>		 * <br/>		 * At the same time it stores the content to the _lastDisplayedContent var		 * if the content is displayed. This var is then used to know if the		 * positions should be computed or not. It will so compute the positions		 * only if the content has changed.		 */		private function updateContent(message:Message, content:IToolBoxContent):Boolean {			var display:Boolean = content.update(message);			if(display){				_lastDisplayedContent = content;				_title.text = content.title;			}			return display;		}						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		private function initialize():void {			var back:Shape = new Shape();			back.graphics.beginFill(0xFF0000, 0);			back.graphics.drawRect(0, 0, 10, 10);						_background		= addChild(new WindowBackground()) as WindowBackground;			_dragBar		= addChild(new GraphicButton(back)) as GraphicButton;			_title			= addChild(new CssTextField("toolBoxTitle")) as CssTextField;			_images			= addChild(new ToolsImage()) as ToolsImage;			_cam			= addChild(new ToolsCam()) as ToolsCam;			_stats			= addChild(new ToolsStats()) as ToolsStats;						visible = false;			_title.mouseEnabled = false;						_cam.addEventListener(Event.RESIZE,		computePositions);			_stats.addEventListener(Event.RESIZE,	computePositions);			_images.addEventListener(Event.RESIZE,	computePositions);			_dragBar.addEventListener(NurunButtonEvent.PRESS,	mouseDownHandler);			_dragBar.addEventListener(NurunButtonEvent.RELEASE,	mouseUpHandler);			_dragBar.addEventListener(NurunButtonEvent.RELEASE_OUTSIDE, mouseUpHandler);		}		/**		 * Resize and replace the elements.		 */		private function computePositions(e:Event = null):void {			if(_lastDisplayedContent == null) return;			var margins:int	= 4;			var headH:int	= 17;			var titleBounds:Rectangle = TextBounds.getBounds(_title);			var target:DisplayObject = _lastDisplayedContent as DisplayObject;			_background.width = Math.max(titleBounds.width + 30, target.width + margins * 2);			_background.height = target.height + headH + margins * 2;			target.x = margins;			target.y = headH + margins;			_title.x = Math.round((_background.width - titleBounds.width) * .5 - titleBounds.x);			_title.y = Math.round((headH - titleBounds.height) * .5 - titleBounds.y);						_dragBar.width = _background.width;			_dragBar.height = headH;						if(x < _dragBounds.x) x = _dragBounds.x;			if(y < _dragBounds.y) y = _dragBounds.y;			if(x > _dragBounds.width - _background.width + _dragBounds.x) x = _dragBounds.width - _background.width + _dragBounds.x;			if(y > _dragBounds.height - _background.height + _dragBounds.y) y = _dragBounds.height - _background.height + _dragBounds.y;						filters = [new DropShadowFilter(2,45,0,.5,2,2,1,1)];		}		/**		 * Called when the window is pressed.		 */		private function mouseDownHandler(e:NurunButtonEvent):void {			var rect:Rectangle = _dragBounds.clone();			rect.width -= _background.width;			rect.height -= _background.height;			startDrag(false, rect);		}		/**		 * Called when the window is released.		 */		private function mouseUpHandler(e:NurunButtonEvent):void {			stopDrag();		}	}}
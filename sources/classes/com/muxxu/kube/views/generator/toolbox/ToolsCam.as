package com.muxxu.kube.views.generator.toolbox {	import com.muxxu.kube.components.LoaderSpinning;	import com.muxxu.kube.components.button.KubeButton;	import com.muxxu.kube.controler.FrontControler;	import com.muxxu.kube.vo.Message;	import com.muxxu.kube.vo.MessageIds;	import com.nurun.components.button.TextAlign;	import com.nurun.structure.environnement.label.Label;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.media.Camera;	import flash.media.Video;	/**	 * Displays the webcam toolbox that allows to fotograph the user.	 * 	 * @author  Francois	 */	public class ToolsCam extends Sprite implements IToolBoxContent {		private var _cam:Video;		private var _capture:KubeButton;		private var _close:KubeButton;		private var _spin:LoaderSpinning;								/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>ToolsCam</code>.		 */		public function ToolsCam() {			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Gets the toolbox title.		 */		public function get title():String { return Label.getLabel("toolBoxTitleCam"); }		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Called on model's update.		 * 		 * @param message	 message data		 * 		 * @return if the content should be displayed or not.		 */		public function update(message:Message):Boolean {			if(message.id == MessageIds.DISPLAY_TOOLS_CAM && !visible) {				visible = true;				startCam();				computePositions();			} else if(MessageIds.isToolBoxMessage(message.id) && visible) {				visible = false;				stopCam();			}			return visible;		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		private function initialize():void {			_spin		= addChild(new LoaderSpinning()) as LoaderSpinning;			_capture	= addChild(new KubeButton(Label.getLabel("toolBoxCaptureCam"))) as KubeButton;			_close		= addChild(new KubeButton(Label.getLabel("toolBoxCaptureExit"))) as KubeButton;						visible				= false;			_close.textAlign	= TextAlign.CENTER;			_capture.textAlign	= TextAlign.CENTER;						_close.addEventListener(MouseEvent.CLICK,	clickButtonHandler);			_capture.addEventListener(MouseEvent.CLICK,	clickButtonHandler);		}		/**		 * Resize and replace the elements.		 */		private function computePositions():void {			if(_cam == null) return;			_capture.y	= _cam.height + 3;			_close.y	= _capture.y;			_capture.width = _close.width = Math.round(_cam.width * .5 - 5);			_close.x	= _cam.width - _close.width;			_spin.x		= _cam.width * .5;			_spin.y		= _cam.height * .5;		}		/**		 * Called when a button is clicked.		 */		private function clickButtonHandler(e:MouseEvent):void {			if(e.currentTarget == _close) {				FrontControler.getInstance().sendMessage(MessageIds.CLOSE_TOOLBOX);			}else if(e.currentTarget == _capture) {				var capture:BitmapData = new BitmapData(_cam.width, _cam.height, false, 0);				capture.draw(_cam);				FrontControler.getInstance().setImageEditorContent(capture);				FrontControler.getInstance().sendMessage(MessageIds.DISPLAY_TOOLS_IMAGE);				capture.lock();			} 		}		/**		 * Starts the webcam.		 */		private function startCam():void {			_spin.open();			var camera:Camera = Camera.getCamera();			camera.setQuality(0, 90);			camera.setMode(480, 360, 31);			_cam = addChild(new Video(camera.width, camera.height)) as Video;			_cam.attachCamera(camera);			computePositions();		}				/**		 * Stops the webcam.		 */		private function stopCam():void {			_spin.close();			_cam.attachNetStream(null);			_cam.attachCamera(null);			removeChild(_cam);			_cam = null;		}	}}